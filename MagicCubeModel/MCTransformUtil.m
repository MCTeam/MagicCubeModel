//
//  MCTransformUtil.m
//  MagicCubeModel
//
//  Created by Aha on 13-3-12.
//  Copyright (c) 2013å¹´ Aha. All rights reserved.
//

#import "MCTransformUtil.h"


@implementation MCTransformUtil

+ (FaceOrientationType)getContraryOrientation:(FaceOrientationType)orientation{
    FaceOrientationType result;
    switch (orientation) {
        case Up:
            result = Down;
            break;
        case Down:
            result = Up;
            break;
        case Front:
            result = Back;
            break;
        case Back:
            result = Front;
            break;
        case Left:
            result = Right;
            break;
        case Right:
            result = Left;
            break;
        default:
            return WrongOrientation;
    }
    return result;
}

+ (NSString *)getRotationTagFromSingmasterNotation:(SingmasterNotation)notation{
    NSString *names[54] = {
        @"frontCW",     @"frontCCW",    @"front2CW",
        @"backCW",      @"backCCW",     @"back2CW",
        @"rightCW",     @"rightCCW",    @"right2CW",
        @"leftCW",      @"leftCCW",     @"left2CW",
        @"upCW",        @"upCCW",       @"up2CW",
        @"downCW",      @"downCCW",     @"down2CW",
        @"xCW",         @"xCCW",        @"x2CW",
        @"yCW",         @"yCCW",        @"y2CW",
        @"zCW",         @"zCCW",        @"z2CW",
        @"frontTwoCW",  @"frontTwoCCW", @"frontTwo2CW",
        @"backTwoCW",   @"backTwoCCW",  @"backTwo2CW",
        @"rightTwoCW",  @"rightTwoCCW", @"rightTwo2CW",
        @"leftTwoCW",   @"leftTwoCCW",  @"leftTwo2CW",
        @"upTwoCW",     @"upTwoCCW",    @"upTwo2CW",
        @"downTwoCW",   @"downTwoCCW",  @"downTwo2CW"
        @"mxCW",        @"mxCCW",       @"mx2CW",
        @"myCW",        @"myCCW",       @"my2CW",
        @"mzCW",        @"mzCCW",       @"mz2CW"
    };
    return names[notation];
}

+ (SingmasterNotation)getSingmasterNotationFromAxis:(AxisType)axis layer:(int)layer direction:(LayerRotationDirectionType)direction{
    SingmasterNotation notation = NoneNotation;
    switch (axis) {
        case X:
        {
            switch (layer) {
                case 0:
                    if (direction == CW) {
                        return Li;
                    } else {
                        return L;
                    }
                    break;
                case 1:
                    if (direction == CW) {
                        return Mi;
                    } else {
                        return M;
                    }
                case 2:
                    if (direction == CW) {
                        return R;
                    } else {
                        return Ri;
                    }
                case NO_SELECTED_LAYER:{
                    if (direction == CW) {
                        return x;
                    }
                    else{
                        return xi;
                    }
                }
                    break;
                default:
                    break;
            }
        }
            break;
        case Y:
        {
            switch (layer) {
                case 0:
                    if (direction == CW) {
                        return Di;
                    } else {
                        return D;
                    }
                    break;
                case 1:
                    if (direction == CW) {
                        return Ei;
                    } else {
                        return E;
                    }
                case 2:
                    if (direction == CW) {
                        return U;
                    } else {
                        return Ui;
                    }
                case NO_SELECTED_LAYER:{
                    if (direction == CW) {
                        return y;
                    }
                    else{
                        return yi;
                    }
                }
                default:
                    break;
            }
        }
            break;
        case Z:
        {
            switch (layer) {
                case 0:
                    if (direction == CW) {
                        return Bi;
                    } else {
                        return B;
                    }
                    break;
                case 1:
                    if (direction == CW) {
                        return S;
                    } else {
                        return Si;
                    }
                case 2:
                    if (direction == CW) {
                        return F;
                    } else {
                        return Fi;
                    }
                case NO_SELECTED_LAYER:{
                    if (direction == CW) {
                        return z;
                    }
                    else{
                        return zi;
                    }
                }
                default:
                    break;
            }
        }
            break;
        default:
            break;
    }
    
    return notation;
}

+ (SingmasterNotation)getContrarySingmasterNotation:(SingmasterNotation)notation{
    if (notation == NoneNotation) {
        return NoneNotation;
    }
    SingmasterNotation result;
    int remainder = notation % 3;
    switch (remainder) {
        case 0:
            result = (SingmasterNotation)((int)notation + 1);
            break;
        case 1:
            result = (SingmasterNotation)((int)notation - 1);
            break;
        case 2:
            result = notation;
            break;
        default:
            result = NoneNotation;
            break;
    }
    return result;
}

+ (SingmasterNotation)getPathToMakeCenterCubieAtPosition:(struct Point3i)coordinate inOrientation:(FaceOrientationType)orientation{
    SingmasterNotation result = NoneNotation;
    switch (orientation) {
        case Up:
            switch (coordinate.y) {
                case 1:
                    result = NoneNotation;
                    break;
                case 0:
                    switch (coordinate.x*2+coordinate.z) {
                        case 1:
                            result = x;
                            break;
                        case -1:
                            result = xi;
                            break;
                        case 2:
                            result = zi;
                            break;
                        case -2:
                            result = z;
                            break;
                        default:
                            break;
                    }
                    break;
                case -1:
                    result = x2;
                    break;
                default:
                    break;
            }
            break;
        case Down:
            switch (coordinate.y) {
                case -1:
                    result = NoneNotation;
                    break;
                case 0:
                    switch (coordinate.x*2+coordinate.z) {
                        case 1:
                            result = xi;
                            break;
                        case -1:
                            result = x;
                            break;
                        case 2:
                            result = z;
                            break;
                        case -2:
                            result = zi;
                            break;
                        default:
                            break;
                    }
                    break;
                case 1:
                    result = x2;
                    break;
                default:
                    break;
            }
            break;
        case Left:
            switch (coordinate.x) {
                case -1:
                    result = NoneNotation;
                    break;
                case 0:
                    switch (coordinate.y*2+coordinate.z) {
                        case 1:
                            result = y;
                            break;
                        case -1:
                            result = yi;
                            break;
                        case 2:
                            result = zi;
                            break;
                        case -2:
                            result = z;
                            break;
                        default:
                            break;
                    }
                    break;
                case 1:
                    result = y2;
                    break;
                default:
                    break;
            }
            break;
        case Right:
            switch (coordinate.x) {
                case 1:
                    result = NoneNotation;
                    break;
                case 0:
                    switch (coordinate.y*2+coordinate.z) {
                        case 1:
                            result = yi;
                            break;
                        case -1:
                            result = y;
                            break;
                        case 2:
                            result = z;
                            break;
                        case -2:
                            result = zi;
                            break;
                        default:
                            break;
                    }
                    break;
                case -1:
                    result = y2;
                    break;
                default:
                    break;
            }
            break;
        case Front:
            switch (coordinate.z) {
                case 1:
                    result = NoneNotation;
                    break;
                case 0:
                    switch (coordinate.x*2+coordinate.y) {
                        case 1:
                            result = xi;
                            break;
                        case -1:
                            result = x;
                            break;
                        case 2:
                            result = y;
                            break;
                        case -2:
                            result = yi;
                            break;
                        default:
                            break;
                    }
                    break;
                case -1:
                    result = y2;
                    break;
                default:
                    break;
            }
            break;
        case Back:
            switch (coordinate.z) {
                case -1:
                    result = NoneNotation;
                    break;
                case 0:
                    switch (coordinate.x*2+coordinate.y) {
                        case 1:
                            result = x;
                            break;
                        case -1:
                            result = xi;
                            break;
                        case 2:
                            result = yi;
                            break;
                        case -2:
                            result = y;
                            break;
                        default:
                            break;
                    }
                    break;
                case 1:
                    result = y2;
                    break;
                default:
                    break;
            }
            break;
        default:
            result = NoneNotation;
            break;
    }
    return result;
}

+ (NSString *)getContenFromPatternNode:(MCTreeNode *)node
              accordingToWorkingMemory:(MCWorkingMemory *)workingMemory{
    NSString *result = nil;
    
    //Before generate the content,
    //detect the wrong type.
    if ([node type] != PatternNode) {
        return nil;
    }
    
    //Generate the content of pattern node
    switch ([node value]) {
        case Home:
        {
            NSMutableString *tmpResult = [NSMutableString stringWithCapacity:24];
            ColorCombinationType identity = ColorCombinationTypeBound;
            MCTreeNode *child;
            for (int i = 0; i < [node.children count]; i++) {
                //Get the child
                child = [node.children objectAtIndex:i];
                
                //The target value varies by type of child
                if (child.type == ElementNode) {
                    identity = (ColorCombinationType)[child value];
                }
                else if (child.type == InformationNode){
                    identity = (ColorCombinationType)[child result];
                }
                
                //Add target cubie description
                [tmpResult appendString:[MCTransformUtil getConcreteDescriptionOfCubie:identity fromMgaicCube:workingMemory.magicCube]];
                
                if (i < [node.children count] - 1) {
                    [tmpResult appendFormat:@","];
                }
            }
            
            //Add suffix
            [tmpResult appendFormat:@"å·²ç»å½ä½ã"];
            
            result = [NSString stringWithString:tmpResult];
        }
            break;
        case Check:
        {
            NSMutableString *tmpResult = [NSMutableString stringWithCapacity:24];
            ColorCombinationType targetCubie = ColorCombinationTypeBound;
            for (MCTreeNode *subPattern in node.children) {
                switch (subPattern.value) {
                    case At:
                    {
                        Point3i targetPosition;
                        
                        //First child node - target cubie
                        MCTreeNode *child = [subPattern.children objectAtIndex:0];
                        //The target value varies by type of child
                        if (child.type == ElementNode) {
                            targetCubie = (ColorCombinationType)[child value];
                        }
                        else if (child.type == InformationNode){
                            targetCubie = (ColorCombinationType)[child result];
                        }
                        
                        //Second child node - target position
                        child = [subPattern.children objectAtIndex:1];
                        //The target value varies by type of child
                        if (child.type == ElementNode) {
                            targetPosition.x = [child value]%3-1;
                            targetPosition.y = [child value]%9/3-1;
                            targetPosition.z = [child value]/9-1;
                        }
                        else if (child.type == InformationNode){
                            targetPosition.x = [child result]%3-1;
                            targetPosition.y = [child result]%9/3-1;
                            targetPosition.z = [child result]/9-1;
                        }
                        
                        [tmpResult appendFormat:@"%@å¨%@",
                                     [MCTransformUtil getConcreteDescriptionOfCubie:targetCubie fromMgaicCube:workingMemory.magicCube],
                                     [MCTransformUtil getPositionDescription:targetPosition]];
                        
                        result = [NSString stringWithString:tmpResult];
                    }
                        break;
                    case ColorBindOrientation:
                    {
                        FaceOrientationType targetOrientation = WrongOrientation;
                        FaceColorType targetColor = NoColor;
                        
                        //First child node - target cubie
                        MCTreeNode *child = [subPattern.children objectAtIndex:0];
                        if (child.type == ElementNode) {
                            targetOrientation = (FaceOrientationType)[child value];
                        }
                        else if (child.type == InformationNode){
                            targetOrientation = (FaceOrientationType)[child result];
                        }
                        
                        //Second child node - target position
                        child = [subPattern.children objectAtIndex:1];
                        //The target value varies by type of child
                        if (child.type == ElementNode) {
                            targetColor = (FaceColorType)[child value];
                        }
                        else if (child.type == InformationNode){
                            targetColor = (FaceColorType)[child result];
                        }
                        
                        //If need, add conjunction
                        if ([subPattern.children count] > 2) {
                            ColorCombinationType targetCubieIdentity = (ColorCombinationType)[(MCTreeNode *)[subPattern.children objectAtIndex:2] value];
                            [tmpResult appendFormat:@"%@%@è²é¢æ%@",
                             [MCTransformUtil getConcreteDescriptionOfCubie:targetCubieIdentity fromMgaicCube:workingMemory.magicCube],
                             [MCTransformUtil getDescriptionOfFaceColorType:targetColor accordingToMagicCube:workingMemory.magicCube],
                             [MCTransformUtil getDescriptionOfFaceOrientationType:targetOrientation]];
                        }
                        else{
                            [tmpResult appendFormat:@"ä¸%@è²é¢æ%@",
                                [MCTransformUtil getDescriptionOfFaceColorType:targetColor accordingToMagicCube:workingMemory.magicCube],
                                [MCTransformUtil getDescriptionOfFaceOrientationType:targetOrientation]];
                            
                        }
                        
                        result = [NSString stringWithString:tmpResult];;
                    }
                        break;
                    case NotAt:
                    {
                        Point3i targetPosition;
                        
                        //First child node - target cubie
                        MCTreeNode *child = [subPattern.children objectAtIndex:0];
                        //The target value varies by type of child
                        if (child.type == ElementNode) {
                            targetCubie = (ColorCombinationType)[child value];
                        }
                        else if (child.type == InformationNode){
                            targetCubie = (ColorCombinationType)[child result];
                        }
                        
                        //Second child node - target position
                        child = [subPattern.children objectAtIndex:1];
                        //The target value varies by type of child
                        if (child.type == ElementNode) {
                            targetPosition.x = [child value]%3-1;
                            targetPosition.y = [child value]%9/3-1;
                            targetPosition.z = [child value]/9-1;
                        }
                        else if (child.type == InformationNode){
                            targetPosition.x = [child result]%3-1;
                            targetPosition.y = [child result]%9/3-1;
                            targetPosition.z = [child result]/9-1;
                        }
                        
                        [tmpResult appendFormat:@"%@ä¸å¨%@",
                         [MCTransformUtil getConcreteDescriptionOfCubie:targetCubie fromMgaicCube:workingMemory.magicCube],
                         [MCTransformUtil getPositionDescription:targetPosition]];
                        
                        result = [NSString stringWithString:tmpResult];
                    }
                        break;
                }
            }
        }
            break;
        case CubiedBeLocked:
        {
            
            if ([node.children count] == 0 ||
                [(MCTreeNode *)[node.children objectAtIndex:0] value] == 0) {
                
                //Avoid no cubie locked
                if ([workingMemory lockerEmptyAtIndex:0]) return nil;
                
                //Get the description of target cubie
                NSString *targetCubie = [MCTransformUtil getConcreteDescriptionOfCubie:[[workingMemory cubieLockedInLockerAtIndex:0]identity] fromMgaicCube:workingMemory.magicCube];
                
                //If no nil, return message
                if (targetCubie != nil) {
                    result = [NSString stringWithFormat:@"éå®ç®æ å°å:%@", targetCubie];
                }
            }
            else{
                return nil;
            }
        }
            break;
        default:
            result = @"Unrecongized pattern node!!!";
            break;
    }
    return result;
}

+ (NSString *)getNegativeSentenceOfContentFromPatternNode:(MCTreeNode *)node
                                 accordingToWorkingMemory:(MCWorkingMemory *)workingMemory{
    NSString *positiveSentence = [MCTransformUtil getContenFromPatternNode:node
                                                  accordingToWorkingMemory:workingMemory];
    return positiveSentence == nil ? nil : [NSString stringWithFormat:@"%@ ä¸ç¬¦å", positiveSentence];
}


+ (void)convertToTreeByExpandingNotSentence:(MCTreeNode *)node{
    //Just expand 'ExpNode' node
    if (node.type != ExpNode) return;
    
    switch (node.value) {
        //Expand 'And' or 'Or' node's children.
        case And | Or:
            for (MCTreeNode *child in node.children) {
                [MCTransformUtil convertToTreeByExpandingNotSentence:child];
            }
            break;
        //Expand 'Not' Node
        case Not:
        {
            //Get its child(only one)
            MCTreeNode *child = [node.children objectAtIndex:0];
            [child retain];
            
            //Before expanding, avoid unexpected node type.
            if (child.type != ExpNode){
                [child release];
                return;
            }
            
            //Process three occasions
            switch (child.value) {
                //Occasion @1 and @2
                case And | Or:
                {
                    //Ancestor node transfer to 'Or' or 'And' node
                    [node setValue:(child.value == And ? Or : And)];
                    
                    //break the relationship not-and or not-or
                    [node.children removeAllObjects];
                    
                    //add new ancestor node's children
                    for (MCTreeNode *andsChild in child.children) {
                        //Construct new 'Not' node.
                        MCTreeNode *newChild = [[MCTreeNode alloc] initNodeWithType:ExpNode];
                        [newChild setValue:Not];
                        
                        [newChild.children addObject:andsChild];
                        //Attach the new node to ancestor node.
                        [node.children addObject:newChild];
                        
                        //count--
                        [newChild release];
                    }
                    break;
                }
                //Occasion @3
                case Not:
                {
                    //Get the node's grandchild
                    MCTreeNode *grandChild = [child.children objectAtIndex:0];
                    [grandChild retain];
                    
                    //Eliminate not-not
                    [node setType:grandChild.type];
                    [node setValue:grandChild.value];
                    [node setChildren:grandChild.children];
                    
                    //Release the hold of grandchild object
                    [grandChild release];
                    
                }
                    break;
                default:
                    break;
            }
            
            //Release the hold of child object
            [child release];
            
            //Deeper Expanding
            [MCTransformUtil convertToTreeByExpandingNotSentence:node];
        }
        default:
            break;
    }
}


+ (NSString *)getConcreteDescriptionOfCubie:(ColorCombinationType)identity fromMgaicCube:(NSObject<MCMagicCubeDataSouceDelegate> *)mc{
    //Check bounds
    if (identity >= ColorCombinationTypeBound || identity < 0) return @"";
    
    //Cubie description length
    const NSInteger cubieDescriptionLength = 12;
    
    //Description result
    NSMutableString *result = [NSMutableString stringWithCapacity:cubieDescriptionLength];
    
    //Get the target cubie by identity(retain once) and skin colors
    NSArray *faceColors = [[[[mc cubieWithColorCombination:identity] getCubieColorInOrientationsWithoutNoColor] allValues] retain];
    
    //Transfer face color type to real color
    for (NSNumber *faceColor in faceColors) {
        [result appendString:[MCTransformUtil getDescriptionOfFaceColorType:(FaceColorType)[faceColor integerValue]
                                                       accordingToMagicCube:mc]];
    }
    
    //Append suffix
    switch ([faceColors count]) {
        case 1:
            [result appendString:@"è²ä¸­å¿å"];
            break;
        case 2:
            [result appendString:@"è²æ£±å"];
            break;
        case 3:
            [result appendString:@"è²è§å"];
            break;
    }
    
    
    //release once
    [faceColors release];
    
    return result;
}


+ (NSString *)getPositionDescription:(Point3i)position{
    switch (position.z) {
        case 1:
            switch (position.y) {
                case 1:
                    switch (position.x) {
                        case 1:
                            return @"åå³ä¸è§";
                        case 0:
                            return @"åä¸æ¹";
                        case -1:
                            return @"åå·¦ä¸è§";
                    }
                    break;
                case 0:
                    switch (position.x) {
                        case 1:
                            return @"åé¢å³è¾¹";
                        case 0:
                            return @"åæ­£ä¸­å¤®";
                        case -1:
                            return @"åé¢å·¦è¾¹";
                    }
                    break;
                case -1:
                    switch (position.x) {
                        case 1:
                            return @"åå³ä¸è§";
                        case 0:
                            return @"åä¸æ¹";
                        case -1:
                            return @"åå·¦ä¸è§";
                    }
                    break;
                default:
                    break;
            }
            break;
        case 0:
            switch (position.y) {
                case 1:
                    switch (position.x) {
                        case 1:
                            return @"ä¸­é´å³ä¸è§";
                        case 0:
                            return @"é¡¶é¢ä¸­å¿";
                        case -1:
                            return @"ä¸­é´å·¦ä¸è§";
                    }
                    break;
                case 0:
                    switch (position.x) {
                        case 1:
                            return @"å³é¢ä¸­å¿";
                        case -1:
                            return @"å·¦é¢ä¸­å¿";
                    }
                    break;
                case -1:
                    switch (position.x) {
                        case 1:
                            return @"ä¸­é´å³ä¸è§";
                        case 0:
                            return @"åºé¢ä¸­å¿";
                        case -1:
                            return @"ä¸­é´å·¦ä¸è§";
                    }
                    break;
            }
            break;
        case -1:
            switch (position.y) {
                case 1:
                    switch (position.x) {
                        case 1:
                            return @"èé¢å³ä¸è§";
                        case 0:
                            return @"èé¢ä¸æ¹";
                        case -1:
                            return @"èé¢å·¦ä¸è§";
                    }
                    break;
                case 0:
                    switch (position.x) {
                        case 1:
                            return @"èé¢å³è¾¹";
                        case 0:
                            return @"èé¢ä¸­å¤®";
                        case -1:
                            return @"èé¢å·¦è¾¹";
                    }
                    break;
                case -1:
                    switch (position.x) {
                        case 1:
                            return @"èé¢å³ä¸è§";
                        case 0:
                            return @"èé¢ä¸æ¹";
                        case -1:
                            return @"èé¢å·¦ä¸è§";
                    }
                    break;
            }
            break;
    }
    return @"";
}

//Internal method
//FaceColorType to real color string(Chinese)
+ (NSString *)getDescriptionOfFaceColorType:(FaceColorType)faceColor
                       accordingToMagicCube:(NSObject<MCMagicCubeDataSouceDelegate> *)mc{
    NSString *realColor = [mc getRealColor:faceColor];
    if ([realColor compare:@"Yellow"] == NSOrderedSame) {
        return @"é»";
    }
    else if ([realColor compare:@"White"] == NSOrderedSame){
        return @"ç½";
    }
    else if ([realColor compare:@"Red"] == NSOrderedSame){
        return @"çº¢";
    }
    else if ([realColor compare:@"Orange"] == NSOrderedSame){
        return @"æ©";
    }
    else if ([realColor compare:@"Blue"] == NSOrderedSame){
        return @"è";
    }
    else if ([realColor compare:@"Green"] == NSOrderedSame){
        return @"ç»¿";
    }
    else{
        return @"";
    }
}

+ (NSString *)getDescriptionOfFaceOrientationType:(FaceOrientationType)orientation{
    switch (orientation) {
        case Up:
            return @"ä¸";
        case Down:
            return @"ä¸";
        case Front:
            return @"å";
        case Back:
            return @"å";
        case Left:
            return @"å·¦";
        case Right:
            return @"å³";
        default:
            return @"";
    }
}

@end
